#!/usr/bin/env node

const fs = require('fs');
const pdf = require('pdf-parse');
const _ = require('lodash');

if (!process.argv[2]) {
  throw new Error('No argv 2');
}



return;

const PAGE_SEPARATOR = '\n\n';
const COLUMN_SEPARATOR = '|';
const LINE_SEPARATOR = '___';

// default render callback
function render_page(pageData) {
  // check documents https://mozilla.github.io/pdf.js/
  let render_options = {
      // replaces all occurrences of whitespace with standard spaces (0x20). The default value is `false`.
      normalizeWhitespace: true,
      // do not attempt to combine same line TextItem's. The default value is `false`.
      disableCombineTextItems: true
  }

  return pageData.getTextContent(render_options)
  .then(function(textContent) {
    // console.log('textContent', textContent);
      let lastY, lastX, text = '';
      for (let i = 0; i < textContent.items.length; i++) {
        const item = textContent.items[i];
        if (pageData.pageIndex === 2) {
          // console.log('text:', item.str, '|', 'transform', item.transform);
        }
        // line is within 10 pixels of previous
        if (lastY - item.transform[5] < 10 || !lastY) {
          // line is on different line, but still same row
          if (lastY != item.transform[5]) {
            text += ` ${LINE_SEPARATOR} `;
          }
          // character is less than 10 pixels away from previous
          if (item.transform[4] - lastX < 10 || !lastX) {
            text += item.str;
          } else {
            text += `${COLUMN_SEPARATOR}${item.str}`;
          }
        } else {
          // create new row
          text += '\n' + item.str;
        }
        lastX = item.transform[4];
        lastY = item.transform[5];
      }
      return text;
  });
}

function printPage(pageText, pageNumber) {
  // console.log(`\n## Page ${pageNumber} ##\n${pageText}`);
}

function splitRowString(str, rowNumber, rows) {
  console.log(`split row ${rowNumber}`, str);
  const row = str ? str.split(COLUMN_SEPARATOR) : str;
  // console.log('-into', row);
  return row;
}

function parseAccountActivityTable(pageInfo, pageNumber, pages) {
  const { 
    pageTitle,
    tableHeaders,
    tableRows,
  } = pageInfo;

  console.log('Account Activity PageInfo page:', pageNumber, '\n', pageInfo);

  const tableDataKeys = splitRowString(tableHeaders[0], pageNumber, pages);
  const tableDataValues = tableRows.map(splitRowString);
  // console.log('tableDataKeys', tableDataKeys);
  // console.log('tableDataValues', tableDataValues);
  
  return {
    pageTitle: pageTitle[0],
    tableHeaders: tableDataKeys,
    tableRows: tableDataValues,
    tableData: tableDataValues.map(row => _.zipObject(tableDataKeys, row))
  };
}

function parsePageData(pageType, lines, index, pages) {

  switch (pageType) {
    case 'ACCOUNT ACTIVITY':
      return parseAccountActivity(lines, index, pages);

    case 'PORTFOLIO SUMMARY':
      return pageInfo;
  }

}

function parsePage(pageText, pageNumber, pages) {
  // skip important info page
  if (pageNumber === 10) return;



  const pageData = parsePageTable(pageType, lines, pageNumber, pages);

  // PORTFOLIO SUMMARY
  // console.log('title', pageTitle);
  // console.log('tableHeaders', tableHeaders);
  // console.log('\nremaining:\n', lines);

  result = {
    pageNumberInfo,
    headerInfo,
    pageData,
    pageType,
  }
  // console.log('\nresult:\n', result);
  if (pageData && pageData.pageTitle && pageData.pageTitle === 'ACCOUNT ACTIVITY') {
    // console.log(pageInfo.tableData);
  }
  return result;
}


let dataBuffer = fs.readFileSync(process.argv[2]);
pdf(dataBuffer, { pagerender: render_page }).then(function (data) {
  // split text by page
  const pages = data.text.split(PAGE_SEPARATOR);
  // parse each page
  pages.forEach(parsePage);
});
